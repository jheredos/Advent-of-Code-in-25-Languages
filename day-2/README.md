# Day 2 - Scala
I learned Scala as a way of familiarizing myself with functional programming, so it always feels synonymous with FP to me. As with Elixir, the pattern matching is a great tool, and it was especially useful with today's problem. I went the lazy route with reading the input and just copied it into the script as a string rather than reading it from a file.

Scala is a bit notorious for its complexity. I've given up trying to understand the difference between covariance and contravariance. I've never touched implicits, either. I guess if you haven't encountered the problem a feature is meant to solve, the feature will never really make sense. For this problem, 80% of the work fell to `match`, leaving 99% of the language untouched.

As much as I love the power and flexibility of Scala, it's not hard to see why it's failed to thrive in the same way that, say, its cousin Kotlin has. With so many features, and support for so many styles of programming, you're bound to encounter vastly different styles between different members of a team or even within the work of one programmer across different projects. It just doesn't encourage consistency. It facilitates creative problem solving to the detriment of predictability, which just adds to the cognitive load. 

The double-edged nature of Scala's flexibility brings to mind [the Lisp Curse](http://www.winestockwebdesign.com/Essays/Lisp_Curse.html).